## Eldritch
This repository holds source material for a game titled Eldritch, to be held at the spring 2016 jtTalks.

Eldritch is an edularp, or educational live-action roleplaying game. It blends elements of fantasy tabletop games like Dungeons and Dragons, programming tutorials in the format of [Jupyter notebooks] (http://jupyter.org/), and game-based learning approaches to computer science such as [CodeCombat](https://codecombat.com/). Students assume the roles of political leaders in the fictional continent of Caeros, which is under attack by hostile subterranean creatures known as aberrants while also facing an internal crisis of governance. An analogy is drawn between real-world programming challanges and in-game uses of the mysterious eldritch tongue, a language whose utterances produce magical effects. By executing snippets of code, students' characters accomplish in-game tasks, accumulate experience points and influence for their factions, and ultimately turn the tide of the invasion.

Additional information on the game world of Eldritch can be found at our [wiki](https://github.com/cferko/eldritch/wiki). The game is designed to be run via the Binder service; to generate a new instance of the Eldritch game on a fresh server, use the link below:

[![Binder](http://mybinder.org/badge.svg)](http://mybinder.org/repo/cferko/eldritch)

All of the source code for the project is in Python and Jupyter notebooks, and is freely available above. The project is still very much in development; documents are incomplete, and code and explanatory text is often incorrect. Individual Jupyter notebooks can be viewed online in browser, but the interactive elements of the simulation can be accessed only if the project is running on a Binder web server.

# Motivation

Substantial educational research has focused on the efficacy of [game-based](https://www.nfer.ac.uk/publications/GAME01/GAME01.pdf) [learning] (https://www.edsurge.com/news/2013-08-19-a-meta-analyses-on-the-research-behind-game-based-learning), and more generally on non-traditional pedagogical approaches such as [active learning](http://www4.ncsu.edu/unity/lockers/users/f/felder/public/Papers/Prince_AL.pdf), [project-based learning](http://bie.org/images/uploads/general/9d06758fd346969cb63653d00dca55c0.pdf), and [inquiry-based learning](http://galileo.org/focus-on-inquiry-lit-review.pdf). Although the results are far from conclusive, preliminary evidence suggests that each of these approaches improves student engagement and learning outcomes over more passive models such as the traditional lecture method.

This trend is especially apparent in computer science. Many educators have shifted to using Jupyter notebooks for their content, which allows for an intrinsically integrated learning experience -- students read expository text, execute code in real-time and see the results, and can modify existing code or write their own code to more effectively engage with the material. The Jupyter format has been used for [multiple](https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python) [textbooks](https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers), for [grading assignments](https://github.com/jupyter/nbgrader), and for [tutorials](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks) of various computational tools and libraries. Finally, the [Binder](http://mybinder.org/) project allows for easy deployability of Jupyter notebooks in an educational setting, providing a standardized and shared environment in which educators and students can interact.

The goal of the Eldritch project is to combine elements from all of these trends and create an experience which is unique and engaging. The goal is not to provide a traditional introduction to computer programming, and students do not come away from the game with a comprehensive background in data structures and flow control. Rather, students are given a whirlwind tour of the most exciting applications of computer science and applied mathematics. Many of the in-game tasks make use of fairly sophisticated mathematical tools with only a high-level explanation of what's going on "under the hood." Rather than formal development and careful proofs, the program focuses on building intuition and experience with using the tools. Overall, this approach avoids much of the instructional overhead and imparts a rough working knowledge of what computer programming can be used for -- the aim is "not the filling of a bucket but the lighting of a fire," so to speak.

# Logistics

The simulation consists of twelve distinct factions, known in the game setting as Marked Houses. Based on limited experience with similar educational games, it seems that the optimal group size in such a context is close to four students (this is sufficiently large for substantial discussion and collaboration, but small enough to avoid fragmentation of students into a small "active" group with other students becoming disengaged.) Thus the target participation size for an iteration of the game is close to 50 students.

In addition, the game runs most smoothly when several facilitators (known henceforth as game masters) are present to interact with students, discuss their progress, and roleplay the results of decisions. Anywhere from 2 to 12 such facilitators can be reasonably supported, with the optimal choice likely around 6.

Before the beginning of the game run, each student is assigned to a particular in-game character and given a link to a "character sheet," a Jupyter notebook which contains background information on the game setting and the student's in-game identity, in addition to a short tutorial which introduces the very basics of computer programming for those students that have no prior experience. This tutorial should take less than an hour to complete and it is preferable that all students do so before the event begins, in order to ensure an even playing field.

When the game begins, a new instance of the Eldritch code repository is spun up on a Binder server. This creates a shared environment through which all of the students and game masters can interact. Each student is then sent a link which opens a personal Jupyter notebook, keyed to that student's in-game identity. The students work together in groups corresponding to their in-game houses to complete a series of programming tasks by writing and evaluating code in their personal Jupyter notebooks. Meanwhile, background code in the Binder environment tracks the code as each student executes it and stores statistics. For example, each student earns experience points as they complete programming tasks, and their roleplaying decisions are stored in a persistent state which can be accessed by other students or affect the dissemination of plot events.

Game masters are given access to an interface which tracks student progress and these statistics. For example, game masters can monitor when a large period of time has passed since a student last completed a challenge and offer help accorodingly, if this is deemed appropriate. Occasionally, a task will require students to interact with those in another group or with a game master (for example, to explain the implementation of one of their algorithms, to negotiate over an in-game disagreement, or to report the results of an analysis). Game masters can observe or participate in these interactions and make notes or assign points accordingly through their game interface.

As the game progresses, students' progress and roleplaying decisions affect the in-game plot and may have downstream consequences. When the game reaches a conclusion, the game masters act out a concluding roleplaying scene which describes the aggregate results of all of these choices, and all runtime data is stored for later analysis. The "live" portion of the game (excluding the tutorial but including the main component in which students work in groups) should take about two hours.

# Learning Goals

Although the Eldritch game does not focus on a traditional curriculum and the experience will differ between participants in different groups, there are a few common take-away messages which it aims to communicate to all students.

* __Computer programming has a low barrier to entry.__ This game allows students to very quickly produce working, useful code without any previous experience in computer science. Students should come away from the experience with the impression that they can learn to code without much overhead.
* __Coding can be used to solve interesting, relevant problems.__ Much of computer science education focuses on fairly abstract material. In this game, students will apply computer programming to tell whether a sample of written text has a positive or negative sentiment, to analyze recorded audio data and make inferences about its source, and to process images and locate features such as faces. These are important, real-world problems with obvious applications.
* __Complicated phenomena can be understood using models, which can be reasoned about precisely and simulated.__ Most of the "campaigns," or sequences of tasks, that student groups work on involve analysis of a real-world system using a mathematical representation. In all cases, students should learn that (1) these complex phenomena can often be adequately represented by simpler models, (2) that one must understand the assumptions and limitations of such models to reason about them, and that (3) computer simulations can be used to extract predictions from these models.
* __Data-driven tasks like prediction, pattern recognition, and decision making can be performed in a quantitative, algorithmic way.__ Every student group will have the opportunity to grapple with data as part of their campaign. In doing so, the students will be asked to draw conclusions from the data, such as identifying a trend or spotting an anomaly. Typically students are accustomed to doing this in a qualitative, ad-hoc way by examining the data manually; in this simulation, they will be instead challenged to design automated ways to generate these inferences without human intervention.